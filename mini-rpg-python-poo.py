# -*- coding: utf-8 -*-
"""desafio-de-poo-em-python-a-jornada-do-her-i.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/devertonfreitas/6293ee66f8570a623186c8f36a7b901b/desafio-de-poo-em-python-a-jornada-do-her-i.ipynb

## Desafio de POO em Python: A Jornada do Herói - Everton Freitas
"""

from __future__ import annotations
from abc import ABC, abstractmethod
from typing import List, Optional, Union
import random

class Arma:
    """
    Representa uma arma com nome e poder de dano.
    """
    def __init__(self, nome: str, poder_dano: int) -> None:
        self.nome = nome
        self.poder_dano = poder_dano

    def __str__(self) -> str:
        return f"{self.nome} (Dano: {self.poder_dano})"


class Pocao:
    """
    Representa uma poção de cura.
    """
    def __init__(self, nome: str, valor_cura: int) -> None:
        self.nome = nome
        self.valor_cura = valor_cura

    def __str__(self) -> str:
        return f"{self.nome} (+{self.valor_cura} vida)"


class Inventario:
    """
    Guarda uma coleção de itens (armas, poções, etc).
    """
    def __init__(self) -> None:
        self._itens: List[object] = []

    def adicionar_item(self, item: object) -> None:
        self._itens.append(item)

    def remover_item(self, item: object) -> None:
        if item in self._itens:
            self._itens.remove(item)

    def listar_itens(self) -> List[object]:
        return list(self._itens)

    def obter_primeira_pocao(self) -> Optional[Pocao]:
        """
        Devolve a primeira poção encontrada, se existir.
        Usada para cura.
        """
        for item in self._itens:
            if isinstance(item, Pocao):
                return item
        return None


class Personagem(ABC):
    """
    Classe base para Guerreiros, Magos, Arqueiros, etc.
    Evita repetição de código entre as classes de heróis.
    """

    def __init__(
        self,
        nome: str,
        vida_maxima: int,
        forca_base: int
    ) -> None:
        self._nome = nome
        self._vida_maxima = vida_maxima
        self._vida = vida_maxima
        self._forca_base = forca_base

        # Um personagem pode ter uma arma e um inventário
        self.arma: Optional[Arma] = None
        self.inventario = Inventario()
        self.habilidades: List[Habilidade] = []

    # ---------------------
    # Encapsulamento da vida
    # ---------------------
    @property
    def vida(self) -> int:
        return self._vida

    @vida.setter
    def vida(self, novo_valor: int) -> None:
        # Proteção contra valores inválidos de vida
        if novo_valor < 0:
            self._vida = 0
        elif novo_valor > self._vida_maxima:
            self._vida = self._vida_maxima
        else:
            self._vida = novo_valor

    @property
    def nome(self) -> str:
        return self._nome

    @property
    def vida_maxima(self) -> int:
        return self._vida_maxima

    # ---------------------
    # Lógica de dano e vida
    # ---------------------
    def receber_dano(self, quantidade: int) -> None:
        """
        Personagem perde vida, mas nunca abaixo de zero.
        """
        self.vida = self.vida - max(0, quantidade)

    def curar(self, quantidade: int) -> None:
        """
        Cura o personagem, respeitando a vida máxima.
        """
        self.vida = self.vida + max(0, quantidade)

    def esta_vivo(self) -> bool:
        """
        Mostra se o personagem ainda está vivo.
        """
        return self.vida > 0

    # ---------------------
    # Ataque e poder de ataque
    # ---------------------
    def calcular_poder_ataque_base(self) -> int:
        """
        Poder de ataque básico = força_base + poder da arma (se houver).
        """
        poder = self._forca_base
        if self.arma is not None:
            poder += self.arma.poder_dano
        return poder

    def calcular_poder_ataque(self) -> int:
        """
        Pode ser especializado nas subclasses.
        Por padrão usa o poder base.
        """
        return self.calcular_poder_ataque_base()

    def atacar(self, alvo: "Personagem") -> None:
        """
        Ação básica de ataque, já considerando o fator sorte no dano.
        """
        if not self.esta_vivo():
            print(f"{self.nome} não pode atacar, está derrotado.")
            return

        dano_base = self.calcular_poder_ataque()
        variacao = Dado.rolar(6) - 3
        dano_total = max(0, dano_base + variacao)

        alvo.receber_dano(dano_total)
        print(
            f"{self.nome} ataca {alvo.nome} causando {dano_total} de dano! "
            f"(vida de {alvo.nome}: {alvo.vida}/{alvo.vida_maxima})"
        )

    # ---------------------
    # Uso de itens
    # ---------------------
    def usar_pocao(self) -> None:
        """
        Usa a primeira poção do inventário, se existir.
        Não ultrapassa a vida máxima.
        """
        pocao = self.inventario.obter_primeira_pocao()
        if pocao is None:
            print(f"{self.nome} não tem poções para usar.")
            return

        self.curar(pocao.valor_cura)
        self.inventario.remover_item(pocao)
        print(
            f"{self.nome} usou {pocao.nome} e agora está com "
            f"{self.vida}/{self.vida_maxima} de vida."
        )

    # ---------------------
    # Habilidades
    # ---------------------
    def adicionar_habilidade(self, habilidade: "Habilidade") -> None:
        self.habilidades.append(habilidade)

    def usar_habilidade(self, indice: int, alvo: "Personagem") -> None:
        """
        Permite que o personagem use qualquer habilidade da sua lista.
        """
        if indice < 0 or indice >= len(self.habilidades):
            print(f"{self.nome} não possui habilidade no índice {indice}.")
            return
        habilidade = self.habilidades[indice]
        habilidade.usar(self, alvo)

    # ---------------------
    # Representação textual
    # ---------------------
    def __str__(self) -> str:
        arma_str = self.arma.nome if self.arma else "Nenhuma"
        return (
            f"{self.__class__.__name__} {self.nome} | "
            f"Vida: {self.vida}/{self.vida_maxima} | "
            f"Força base: {self._forca_base} | "
            f"Arma: {arma_str}"
        )


class Guerreiro(Personagem):
    """
    Guerreiro básico.
    """
    def calcular_poder_ataque(self) -> int:
        """
        Guerreiro pode ter um bônus de força física.
        """
        return int(self.calcular_poder_ataque_base() * 1.1)


class Mago(Personagem):
    """
    Mago com poder mágico adicional.
    """
    def __init__(
        self,
        nome: str,
        vida_maxima: int,
        forca_base: int,
        poder_magico: int
    ) -> None:
        super().__init__(nome, vida_maxima, forca_base)
        self.poder_magico = poder_magico

    def calcular_poder_ataque(self) -> int:
        """
        Ataque do mago é mais forte com poder mágico.
        """
        return self.calcular_poder_ataque_base() + self.poder_magico


class Arqueiro(Personagem):
    """
    Arqueiro com atributo de precisão.
    """
    def __init__(
        self,
        nome: str,
        vida_maxima: int,
        forca_base: int,
        precisao: int
    ) -> None:
        super().__init__(nome, vida_maxima, forca_base)
        self.precisao = precisao

    def calcular_poder_ataque(self) -> int:
        """
        Ataque do arqueiro leva em conta a precisão.
        """
        bonus = int(self.precisao * 0.3)
        return self.calcular_poder_ataque_base() + bonus


class Monstro(Personagem):
    """
    Classe genérica para monstros.
    """
    def __init__(
        self,
        nome: str,
        vida_maxima: int,
        forca_base: int
    ) -> None:
        super().__init__(nome, vida_maxima, forca_base)

    @classmethod
    def goblin_padrao(cls) -> "Monstro":
        """
        Fábrica para gerar Goblins.
        """
        return cls(nome="Goblin", vida_maxima=30, forca_base=6)


class Orc(Monstro):
    """
    Orc com chance de golpe crítico.
    """
    def atacar(self, alvo: Personagem) -> None:
        if not self.esta_vivo():
            print(f"{self.nome} não pode atacar, está derrotado.")
            return

        dano_base = self.calcular_poder_ataque()
        critico = Dado.rolar(100) <= 25  # 25% de chance de crítico

        if critico:
            dano_base *= 2
            print(f"GOLPE CRÍTICO de {self.nome}!")

        variacao = Dado.rolar(6) - 3
        dano_total = max(0, dano_base + variacao)

        alvo.receber_dano(dano_total)
        print(
            f"{self.nome} ataca {alvo.nome} causando {dano_total} de dano! "
            f"(vida de {alvo.nome}: {alvo.vida}/{alvo.vida_maxima})"
        )

class Habilidade(ABC):
    """
    Classe das habilidades.
    Toda habilidade precisa implementar 'usar'.
    """
    def __init__(self, nome: str) -> None:
        self.nome = nome

    @abstractmethod
    def usar(self, usuario: Personagem, alvo: Personagem) -> None:
        """
        Executa o efeito da habilidade.
        """
        pass

    def __str__(self) -> str:
        return self.nome


class AtaqueForte(Habilidade):
    """
    Habilidade que executa um golpe pesado.
    """
    def __init__(self) -> None:
        super().__init__("Ataque Forte")

    def usar(self, usuario: Personagem, alvo: Personagem) -> None:
        if not usuario.esta_vivo():
            print(f"{usuario.nome} não pode usar {self.nome}, está derrotado.")
            return

        dano_base = usuario.calcular_poder_ataque()
        dano = int(dano_base * 1.5) + (Dado.rolar(4) - 2)
        dano = max(0, dano)

        alvo.receber_dano(dano)
        print(
            f"{usuario.nome} usa {self.nome} em {alvo.nome}, "
            f"causando {dano} de dano! "
            f"(vida de {alvo.nome}: {alvo.vida}/{alvo.vida_maxima})"
        )


class BolaDeFogo(Habilidade):
    """
    Habilidade padrão do mago.
    """
    def __init__(self) -> None:
        super().__init__("Bola de Fogo")

    def usar(self, usuario: Personagem, alvo: Personagem) -> None:
        if not usuario.esta_vivo():
            print(f"{usuario.nome} não pode usar {self.nome}, está derrotado.")
            return

        poder_magico = getattr(usuario, "poder_magico", 0)
        dano_base = usuario.calcular_poder_ataque_base() + poder_magico * 2
        dano = dano_base + (Dado.rolar(6) - 1)
        dano = max(0, dano)

        alvo.receber_dano(dano)
        print(
            f"{usuario.nome} lança {self.nome} em {alvo.nome}, "
            f"causando {dano} de dano! "
            f"(vida de {alvo.nome}: {alvo.vida}/{alvo.vida_maxima})"
        )


class Dado:
    """
    Classe utilitária para rolagem de valores aleatórios.
    """
    @staticmethod
    def rolar(lados: int = 20) -> int:
        """
        Rola um dado com a quantidade de lados informada.
        """
        return random.randint(1, lados)


class Batalha:
    """
    Gerencia um confronto entre combatentes, combate 1x1 e combate em equipes.
    """

    def __init__(
        self,
        lado1: Union[Personagem, List[Personagem]],
        lado2: Union[Personagem, List[Personagem]]
    ) -> None:
        self.lado1: List[Personagem] = (
            lado1 if isinstance(lado1, list) else [lado1]
        )
        self.lado2: List[Personagem] = (
            lado2 if isinstance(lado2, list) else [lado2]
        )

    # ---------------------
    # Batalha 1x1
    # ---------------------
    @staticmethod
    def duelo(simples1: Personagem, simples2: Personagem) -> Personagem:
        """
        Executa uma batalha de turnos entre dois combatentes.
        """
        atacante = simples1
        defensor = simples2
        turno = 1

        print(f"\n--- INÍCIO DO DUELO: {simples1.nome} vs {simples2.nome} ---")
        while atacante.esta_vivo() and defensor.esta_vivo():
            print(f"\n[TURNO {turno}] {atacante.nome} ataca!")
            atacante.atacar(defensor)
            # troca os papéis
            atacante, defensor = defensor, atacante
            turno += 1

        vencedor = atacante if atacante.esta_vivo() else defensor
        print(f"\n*** VENCEDOR DO DUELO: {vencedor.nome}! ***\n")
        return vencedor

    # ---------------------
    # Batalha em equipe
    # ---------------------
    def batalha_em_equipes(self) -> List[Personagem]:
        """
        Executa combate em turnos entre duas equipes.
        A batalha termina quando todos de um lado caem.
        """
        print("\n=== INÍCIO DA BATALHA EM EQUIPE ===")
        print("Equipe 1:", ", ".join(p.nome for p in self.lado1))
        print("Equipe 2:", ", ".join(p.nome for p in self.lado2))

        indice1 = 0
        indice2 = 0
        turno = 1

        while any(p.esta_vivo() for p in self.lado1) and any(p.esta_vivo() for p in self.lado2):
            print(f"\n[TURNO {turno}]")

            # pega o próximo vivo de cada lado
            while indice1 < len(self.lado1) and not self.lado1[indice1].esta_vivo():
                indice1 += 1
            while indice2 < len(self.lado2) and not self.lado2[indice2].esta_vivo():
                indice2 += 1

            if indice1 >= len(self.lado1) or indice2 >= len(self.lado2):
                # alguém não tem mais combatentes vivos
                break

            combatente1 = self.lado1[indice1]
            combatente2 = self.lado2[indice2]

            # lado 1 ataca
            combatente1.atacar(combatente2)
            if combatente2.esta_vivo():
                # se o do lado 2 sobreviver, revida
                combatente2.atacar(combatente1)

            turno += 1

        # determina equipe vencedora
        vivos1 = [p for p in self.lado1 if p.esta_vivo()]
        vivos2 = [p for p in self.lado2 if p.esta_vivo()]

        if vivos1 and not vivos2:
            vencedores = vivos1
            print("\n*** EQUIPE VENCEDORA: EQUIPE 1 ***")
        elif vivos2 and not vivos1:
            vencedores = vivos2
            print("\n*** EQUIPE VENCEDORA: EQUIPE 2 ***")
        else:
            # empate ou todos mortos
            vencedores = vivos1 + vivos2
            print("\n*** BATALHA TERMINOU EM EMPATE ***")

        print("Sobreviventes:")
        for p in vencedores:
            print(f"- {p.nome} ({p.vida}/{p.vida_maxima} de vida)")

        print("\n=== FIM DA BATALHA EM EQUIPE ===\n")
        return vencedores

# Armas
espada_longa = Arma("Espada Longa", poder_dano=10)
cajado_magico = Arma("Cajado Mágico", poder_dano=7)

# Poção
pocao_de_vida = Pocao("Poção de Vida", valor_cura=20)

# Goblin
goblin_padrao = Monstro.goblin_padrao()